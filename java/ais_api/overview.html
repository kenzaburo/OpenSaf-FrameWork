<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_04) on Wed Aug 06 14:36:52 CEST 2008 -->
<TITLE>
Overview (SA Forum - Java AIS API)
</TITLE>

<META NAME="date" CONTENT="2008-08-06">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (SA Forum - Java AIS API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
SA Forum - Java AIS API (R2 A.01.01)</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H1>
Service Availability Forum - Java AIS API
</H1>
</CENTER>
This set of packages
(published under the <a href="org/saforum/ais/doc-files/SAF_licensing_agreement.pdf">Service Availability Forum Specification License Agreement</a>)
defines a Java language binding that provides access to high availability middleware
implementations compliant with the Application Interface Specification defined by <a href="http://www.saforum.org/">Service Availability Forum</a>.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/saforum/ais/package-summary.html">org.saforum.ais</A></B></TD>
<TD>This package contains common types and constants for the AIS service APIs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/saforum/ais/amf/package-summary.html">org.saforum.ais.amf</A></B></TD>
<TD>This package contains common types and constants of the Java language binding for
the AIS Availability Management Framework defined by <a href="http://www.saforum.org/">Service Availability Forum</a>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/saforum/ais/clm/package-summary.html">org.saforum.ais.clm</A></B></TD>
<TD>This package contains common types and constants of the Java language binding for
the AIS Cluster Membership Service defined by <a href="http://www.saforum.org/">Service Availability Forum</a>.</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
This set of packages
(published under the <a href="org/saforum/ais/doc-files/SAF_licensing_agreement.pdf">Service Availability Forum Specification License Agreement</a>)
defines a Java language binding that provides access to high availability middleware
implementations compliant with the Application Interface Specification defined by <a href="http://www.saforum.org/">Service Availability Forum</a>. </p>
<p>Copyright statement is specified <a href="#Copyrights">here</a>. </p>
<h2><a name="AIS" id="AIS">Java Mapping for AIS APIs: Overview</a></h2>

<h3><a name="Introduction" id="Introduction">Introduction</a></h3>

This set of packages defines a Java API that provides access to high availability middleware
implementations compliant with the Application Interface Specification defined by
<a href="http://www.saforum.org/">Service Availability Forum</a> (also referred to as SA Forum or SAF).
If you are not familiar with the terms SA Forum and AIS, the next two sections give you a very brief overview.
Otherwise you can jump to the <a href="#principles">Design principles</a> section.

<h4><i><a name="Background" id="Background">Background</a></i></h4>

The <a href="http://www.saforum.org/">Service Availability Forum</a> (SAF or SA Forum) is a consortium of industry-leading
communications and computing companies working together to foster an ecosystem that enables the use of commercial
off-the-shelf building blocks in the creation of high availability network infrastructure products, systems and services. 
The SA Forum develops and publishes high availability and management software interface specifications.

<P>The Application Interface Specification (AIS) defined by SA Forum standardizes the interface between
a SAF-compliant High Availability (HA) middleware and service applications. AIS defines a set of AIS Services, which are services
designed to support highly available applications in a cluster. Furthermore, AIS Frameworks are AIS Services 
that in addition to providing service for their clients also define an information model that these clients must use.

<P>The current AIS release (B.01.01, i.e. Release 2) defines the following services and frameworks:
Availability Management Framework (AMF), 
Cluster Membership Service (CLM), 
Checkpoint Service (CKPT),
Message Service (MSG),
Event Service (EVT) and
Lock Service (LCK).

Further AIS services may be specified in future releases by SA Forum.

<P>The following AIS services and frameworks are supported in this release of Java APIs:
<ul>

  <li><A HREF="org/saforum/ais/amf/package-summary.html"><CODE>Availability Management Framework</CODE></A> (AMF):
  AMF is the software entity that provides service availability by coordinating redundant resources within a cluster
  to deliver a system with no single point of failure. AMF provides a set of APIs to enable high levels of
  service availability.</li>

  <li><A HREF="org/saforum/ais/clm/package-summary.html"><CODE>Cluster Membership Service</CODE></A> (CLM): CLM provides applications with membership information
    about the nodes that have been administratively configured in the cluster configuration.
    
</ul>

<P>In the future SA Forum will publish Java API mappings according to the following guidelines:
<OL>
<LI>It is expected that additional Java API mappings for most of the AIS services will be provided in future releases.
<LI>Already existing Java API mappings will be updated in future AIS releases.
<LI>Java API mappings for earlier releases (i.e. before Release 5) will only be specified upon request. If someone would like to see a 
Java API for an earlier version for some of the services, then that person/organization must first create a candidate proposal. In order to
enforce the 2nd rule above, the candidate proposal must also provide missing mappings for all subsequent releases.
SA Forum will review and eventually publish these
candidate proposals. (This Java API mapping - intended for Release 2 - is an example of this guideline.)
</OL>

<h4><i><a name="Specifications" id="Specifications">Related AIS Specification documents for B.01.01 (Release 2, November 22, 2004)</a></i></h4>

SA Forum provides a general AIS overview document and separate specification documents for each AIS service.
These documents are available from <a href="http://www.saforum.org/">www.saforum.org</a>:
<UL>
<LI>The AIS overview document <b>SAI-Overview-B.01.01</b> provides a brief guide to all AIS services.
It describes the objectives of the AIS services as
well as programming models and definitions that are common to all AIS specifications.
<LI>The document <b>SAI-AIS-AMF-B.01.01</b> describes the Availability Management Framework,
<LI><b>SAI-AIS-CLM-B.01.01</b> describes the Cluster Membership Service,
</UL>

<P>The above specification documents define the semantics of the services 
and also describe the APIs provided for applications using the services
(the APIs are defined in the C programming language). If you are not familiar with these
specification documents, you are strongly advised to study them: this javadoc can be used as a
programming reference, but it does not explain the underlying AIS services. Furthermore, the  knowledge of the
C API will help understand the Java API as certain patterns are "imported" from the C API.

<P>The specification for the Java mapping contains two documents:
<ul>

  <li> <B>SAIM-AIS-R2-JD-A.01.01</B> (this javadoc):
  Javadoc for Java AIS APIs supporting AIS B.01.01 (Release 2) 
  <li> <B>SAIM-AIS-R2-JC-A.01.01</B> (the java sources):

  Java source files for the org.saforum.ais.* packages.
  These source files are intended to ease both the implementation of the Java mappings and
  the development of Java applications using the specified API.
  Most of the files simply define the interfaces from this javadoc.
  Some implementation code has been added (the most important example is 
  <A HREF="org/saforum/ais/FactoryImpl.html" title="class in org.saforum.ais"><CODE>FactoryImpl</CODE></A>) to facilitate quick implementation of these APIs.
  Implementors are allowed (though not encouraged) to replace the implementation parts as
  long as the contract of the interfaces (as defined in this javadoc) is fully respected.    
</ul>



<h4><i><a name="Principles" id="Principles">Design principles</a></i></h4>

<p>The AIS service API definitions in Java are based very closely on
the corresponding C language APIs for AIS. They are designed so that:</p>

<ul>

  <li>The implementation language of the area servers is independent of the
    client library language implementations</li>

  <li>It should be possible to mix-and-match C and Java components in the
    same SAF cluster</li>

  <li>There is no more and no less functionality in the Java API
    than in the C API</li>

  <li>The semantics of the Java interfaces are generally identical to the
    corresponding C interfaces.</li>

  <li>No particular Java application model is assumed. The API can be utilized 
  by any Java SE or Java EE application environments.</li>
    
  <li>The API requires Java 5 or later versions.</li>

</ul>

<h3><a name="Introduction" id="Introduction">Java API Design</a></h3>

<h4><i><a name="Package" id="Package">Package structure</a></i></h4>

<p>There are presently two levels of packages:</p>

<dl>

  <dt>org.saforum.ais</dt>

    <dd>This package factors out definitions common to all AIS services. It roughly
      corresponds to the "ais.h" header file. Additionally, it contains library handle interfaces
      providing lifecycle control and the infrastructure for asynchronous communication between the AIS
      services and the client code. Finally, it adds a generic
      factory class to provide the entry point for the client code.</dd>

  <dt>org.saforum.ais.&lt;service&gt;</dt>

    <dd>There is a package for each service: e.g. "amf", 
      "clm" and so on. These contain the definitions common to the service. 
      The service specific library handle interface (<tt>&lt;Area&gt;Handle</tt> and its factory 
      <tt>&lt;Area&gt;HandleFactory</tt> are  
      located in this package.</dd>

</dl>

<h4><i><a name="Interfaces" id="Interfaces">Interface oriented design</a></i></h4>

<p>The functionality of the AIS services is presented to the client code by Java methods. These methods are 
declared in interfaces rather than in classes. Interfaces preserve the separation between implementation and
specification as well as keeping the class hierarchy flexible.</p>

<h4><i><a name="Model" id="Model">Programming model</a></i></h4>


<p>The AIS library life cycle is based upon the following model:</p>

<ol>

  <li>The client code (i.e. the AIS component) initializing a dynamic entity representing the association between the client and the AIS area server.</li>

  <li>The client code communicating with the area server via the entity.</li>

  <li>The client code shutting down the association when it is not needed any more.</li>

</ol>

In the Java API this generic model is translated to the following steps:

<ol>

  <li>The client code obtaining an <tt>&lt;Area&gt;Handle</tt> object (the library handle).
 </li>

  <li>The client code communicating with the area server by invoking methods on the library handle
   or on other closely associated objects.</li>

  <li>The client code shutting down the library handle by invoking its <tt>finalizeHandle()</tt> method,
    which makes its further use invalid.</li>

</ol>
<P>Thus, the core object of each service is the <tt>&lt;Area&gt;Handle</tt>, representing the dynamic association between
the AIS component and the AIS area server. This object:
<UL>
<LI>Encapsulates library life cycle (together with the <tt>&lt;Area&gt;HandleFactory</tt>),
<LI>Supports asynchronous communication between AIS area server and the AIS component (via registering,
detecting and dispatching callbacks)
<LI>Finally it is a gateway to other objects representing the API calls of the particular AIS service.
</UL>
<P>The client usually is free to use more than one <tt>&lt;Area&gt;Handle</tt> objects to
communicate with the area server (the only restriction applies to AMF, which allows only a single library handle to carry out operations
that require registration).


<P><a name="#initializeCallbacks">The two AIS library <b>life cycle</b> operations are the initialization and the finalization of the library handle. 
<b>Initialization</b> is done by invoking the <tt>initializeHandle()</tt> method
of the appropriate service factory object (i.e. <tt>&lt;Area&gt;HandleFactory</tt>). 
The client code must specify the <A HREF="org/saforum/ais/Version.html" title="class in org.saforum.ais"><CODE>Version</CODE></A> of the requested AIS service and pass a
<tt>&lt;Area&gt;Callbacks</tt> object containing the set of implemented callback interfaces
used by the library for asynchronous communication.</a>
<P><a name="#FactoryFramework"></a>The factory framework is specified in the following manner</a>:
</p>

<ul>

  <li>The factory method <tt>initializeHandle()</tt> is defined by an interface named
    <A HREF="org/saforum/ais/Factory.html" title="interface in org.saforum.ais"><CODE>Factory</CODE></A>.  All the service factory objects implement this interface. This
    is a generic interface parameterized by the service interface ("S", representing the library handle) and
    the callback class ("C", representing the set of callback - or listener, if you like - interfaces used by the library
        for asynchronous communication).</li>

  <li>A <A HREF="org/saforum/ais/Callbacks.html" title="class in org.saforum.ais"><CODE>Callbacks</CODE></A> abstract class has been added, from which all other callback classes
    derive. This class is empty: i.e. it extends Object but
    without adding or changing anything.  It is used as a marker for the
    generic interfaces.</li>

  <li>Because of the use of interfaces, the factory methods can not be
    static.  Hence, it is required to create a factory object using the
    default constructor prior to calling the factory method (i.e. <tt>initializeHandle()</tt>).</li>

  <li>As well as sharing common interfaces, the factories share an
    implementation (the 
    class loading of the selected implementation class). This has been
    factored out into the abstract class <A HREF="org/saforum/ais/FactoryImpl.html" title="class in org.saforum.ais"><CODE>FactoryImpl</CODE></A> in the "ais" package.</li>

</ul>


<p>The <b>finalization</b> is done by invoking the <tt>finalizeHandle()</tt> method on the <tt>&lt;Area&gt;Handle</tt> object.
This makes it invalid for further use, but note that the references of <tt>&lt;Area&gt;Handle</tt> and the related objects still
need to be dropped to give the garbage collector a chance to clean up.

<p>The library handle provides the infrastructure for <b>asynchronous communication</b> between the client and the AIS area server.
This infrastructure has three elements:
<UL>
<LI>The <b>set of callback objects</B> that are invoked when a requested asynchronous operation is ready.
The callback objects (aka as listeners in the usual Java terminology) must be provided when the library handle is initialized
(see <a href="#initializeCallbacks">above</a>) and they are permanently associated to the library handle until the library handle is finalized.
Note that client code is free to provide null for any callback object if it
does not want to use the operation associated with that particular callback.
<LI>Methods that control the <b>dispatching of callbacks</B>. Unlike most Java implementations of the Listener pattern, this Java
API delegates the task of actually invoking a callback to the client code. The API implementation never invokes a callback directly.
Instead, callbacks are invoked in a strictly controlled way, from a thread owned by the client. This allows the client to be
truly single-threaded, if necessary. Thus, pending callbacks are always invoked in the context of the <tt>dispatch()</tt> method
of the library handle.
<LI>Methods for <b>detection of pending callbacks</b>. The library handle provides several forms of the <tt>dispatch()</tt>
method. Some will return immediately if there is no pending callback, some will block until a callback becomes pending, some will
 specify a time-out before returning. Furthermore, the library handle provides methods for checking the availability of
 callbacks without actually dispatching them (see the <tt>hasPendingCallback()</tt> methods). Last but not least, the library handle supports 
 multiplexed callback selection by integrating this API with the NIO framework: the <tt>getSelectableChannel()</tt> method will
 return a SelectableChannel object that can be used by NIO Selectors.
</UL>

<p>Finally, the library handle provides a <b>gateway for service specific API functionality</b>.
In order to avoid the creation of a potentially huge 
spaghetti class, <tt>&lt;Area&gt;Handle</tt> objects do not declare
methods offering service specific API functionality directly. Instead, service specific methods are implemented
by closely associated objects and the library handle provides methods returning references to
these associated objects. These library handle methods (and consequently the associated objects)
come in two different flavours:
<UL>
<LI>"Getter" methods return references to objects that have a 
one-to-one association with the library handle (i.e. the first invocation of the 
getter method will create the object and cache a reference to it. Subsequent invocations 
of the getter method will return the cached reference). These objects simply bundle 
the methods providing part of the service by the AIS area server.
(For instance, <A HREF="org/saforum/ais/amf/AmfHandle.html" title="interface in org.saforum.ais.amf"><CODE>AmfHandle</CODE></A>
declares many getter functions: <tt>getComponentRegistry()</tt>, <tt>getCsiManager()</tt>, etc. 
that in turn return the <A HREF="org/saforum/ais/amf/ComponentRegistry.html" title="interface in org.saforum.ais.amf"><CODE>ComponentRegistry</CODE></A>, 
<A HREF="org/saforum/ais/amf/CsiManager.html" title="interface in org.saforum.ais.amf"><CODE>CsiManager</CODE></A>, etc. objects defining various  
methods of the AMF API, respectively. These objects are pure
Java objects and therefore require no special method for clean-up after use.
<LI>"Creator" methods (following the naming convention of <tt>create&lt;Entity&gt;</tt>) 
return references to <tt>&lt;Entity&gt;</tt> objects that are not only bundles for
API methods, but also require allocation of resources. 
Each invocation of such a creator method produces a new object and
allocates new resources.
If the allocated resources are controlled by the AIS area server, 
the created object will have a method named <tt>destroy()</tt> that must be invoked if
<tt>&lt;Entity&gt;</tt> is not required any more: it will then release the allocated 
resources and make further use of the <tt>&lt;Entity&gt;</tt> object invalid. If the 
the allocated resources comprise only memory, then no such method is needed: the garbage collector
will free the allocated resources, as usual in Java.
</UL>

<h4><i><a name="Threads" id="Threads">Threading model</a></i></h4>

Sa Forum mandates that the service libraries implementing the C APIs do not have hidden threads, thus allowing
a truly single-threaded process to utilize these libraries. This rule may seem obsolete in Java at first sight,
as Java has built-in language support for multiple threads. Nevertheless, there are Java application frameworks that
rely on a single-threaded application model, i.e. the framework itself may consist of multiple threads but the applications
executed by the framework are assigned a single thread and prohibited from creating multiple threads.

Consequently, the Java AIS API libraries must be implemented according to the following rules:
<UL>
<LI>The API implementation <B>must</B> support Java applications that run all their code in a single thread,
controlled by the application itself. (That is why the dispatching mechanism of the C APIs has been 
adapted in the Java APIs.)
<LI>The API implementation <B>should</B> try to minimize the number of hidden threads. Unlike in the C library
implementations, it is not forbidden to have hidden threads. For example, it is foreseen that hidden threads
may be needed for supporting callback multiplexing via SelectableChannel objects. However, the implementation
should try to minimize the number of thread and should limit their existence as much as possible. For example,
per-application hidden threads should be avoided. Also, hidden threads should be created dynamically, only 
when the application first uses the API for which the threads are necessary.
<LI>If the API implementation uses hidden threads, their existence <B>must</B> be clearly and thoroughly documented,
including their numbers and the conditions under which they exist.
</UL>    


<h3><a name="Comparison" id="Comparison">Comparison of Java and C APIs</a></h3>

This section is primarily intended to readers who are familiar with the C AIS API and
would like to know what are the differences and the similarities between the Java API and C API.

<h4><i><a name="Naming" id="Naming">Naming conventions</a></i></h4>

<P>As a general rule, the Java API uses commonly accepted 
<a href="http://java.sun.com/docs/codeconv/html/CodeConventions.doc8.html#367">naming conventions</a>.
These conventions dictate using uppercase letters to begin type names,
lowercase letters for methods, all caps for constants, and all lower case letters
for packages. Also note that method names start with a verb, followed by the subject
of the action.

<P>The C AIS API uses naming conventions that heavily rely on the usage of service specific prefixes
(sa, saAmf, saCkpt, etc.). These prefixes reflect the lack of namespaces in C language. Since Java packages do provide namespaces,
the Java API does not generally use these prefixes. This rule applies to all public names, i.e. classes, methods, formal parameters, fields, constants.
There are a few exceptions, though:
<UL>
<LI>Exception classes representing AIS errors have an <tt>Ais</tt> prefix, e.g. <A HREF="org/saforum/ais/AisLibraryException.html" title="class in org.saforum.ais"><CODE>AisLibraryException</CODE></A>
<LI>It is often necessary to make a visible distinction of the supported service for types/objects that 
could potentially serve any one of the AIS services. For instance, classes representing the library instances will retain
a service specific prefix (e.g <A HREF="org/saforum/ais/amf/AmfHandle.html" title="interface in org.saforum.ais.amf"><CODE>AmfHandle</CODE></A> instead of <tt>org.saforum.ais.amf.Handle</tt>, etc.).

<LI>Constants representing AIS-specific time values retain the SA_TIME prefix (see <A HREF="org/saforum/ais/Consts.html" title="class in org.saforum.ais"><CODE>Consts</CODE></A>).

</UL>

<a name="#NamingExample"><P>The result of these rules is that most names of the Java API are shorter than the corresponding C API name. Nevertheless,
it is still very easy to "find" corresponding names of the two APIs. For example, 
<tt>saAmfComponentRegister()</tt> becomes <tt>registerComponent()</tt> (see <A HREF="org/saforum/ais/amf/ComponentRegistry.html" title="interface in org.saforum.ais.amf"><CODE>ComponentRegistry</CODE></A>).</a>

<h4><i><a name="Compatibility" id="Compatibility">Backward Compatibility rules in Java</a></i></h4>

As a general rule, the Java APIs follow the same principle concerning backward compatibility
as the C APIs: the Java APIs are defined in such a way that they must not prevent 
implementations from supporting
older versions of the API if they decide so (although implementations are not mandated to do that). However, due
to the differences between the two languages, there are some differences in the actual guidelines on
backward compatibility as well: 
<UL>
<LI>The C APIs of AIS force the definition of a new type when a field is added to a data structure. The new 
type name is built from the original name in the previous version with a suffix indicating the version where the type
changed (for instance, <tt>SaAmfCallbacksT</tt> becomes in <tt>SaAmfCallbacksT_3</tt> in AMF B.03.01). <B>This rule is not followed
in the Java API</B>. (In general, as Java APIs follow the new releases of AIS over time, the practice of creating a 
new type name with a suffix indicating the new version will be avoided as much as possible.) 
Instead, the class name remains the same  and a new field is added to it. Client code that uses an old version
still remains comaptible due to the dynamic way Java class files are linked. Thus, for instance the name of
<A HREF="org/saforum/ais/amf/AmfHandle.Callbacks.html" title="class in org.saforum.ais.amf"><CODE>AmfHandle.Callbacks</CODE></A>) does not change in AMF B.03.01, even though it is extended with two new fields.

<LI>Similarly, The C APIs of AIS force the definition of a new function when the function signature changes. The new 
function name is built using a suffixes explained above. <B>This rule is not followed
in the Java API</B>. Instead, we use method name overloading and 
a new method with the same name but a different signature is defined. Client code that uses an old version
can still remain compatible as the Java runtime will automatically find the proper method based on its signature.
</UL>

 
<h4><i><a name="Constants" id="Constants">Constants</a></i></h4>

Constants are defined in the Java API using two typical flavours:

<P><b>Enumerated types</b> (<tt>Enum</tt> classes) are used to define most constant values.
The basic form of Java <tt>Enum</tt>s defines a set of symbolic identifiers without explicitly assigning a numeric value
to the identifiers. In the Java AIS API enums are extended so that each symbolic identifier is tied to the numeric value defined by
the corresponding C API definition. The reason for this extension is that the Java client may have to forward the numeric value
to a non-Java entity within the SA Forum cluster (e.g. embed the value into a message or a log).

<P>The Java API uses <b>public static final fields</b> of the appropriate primitive type for constants that cannot be 
<tt>Enum</tt>s. Enumerated types are in general more favourable, but they cannot always be used to define constants, mostly because
the set of legal values of an enumeration type is strictly limited to those listed in its definition. As a consequence:
<UL>
<LI>Enumerated types cannot be used to combine several constant values using bitwise operations (i.e. for "flags"),
<LI>Enumerated types cannot be used to define a few typical constant values for a larger or unlimited set of legal values,
e.g. special time/duration constants.
</UL>

<h4><i><a name="Types" id="Types">Types</a></i></h4>

The C API defines a fairly high number of special data types that are used primarily
to pass information between the underlying middleware and the client code. These data types
are converted "directly" in the Java API. The following guidelines are used when
converting the types of the C API:

<P><b>Primitive data types</b> are usually converted to their Java counterparts of the 
same bit-size. E.g. a type defined in the C API as <tt>SaInt16T</tt>
(directly or via <tt>typedef</tt>) is mapped to a <tt>short</tt> type in the Java API.
However, there are a few exceptions. Certain unsigned values in the C API represent identifiers/handles
that are converted into full-scale
Java objects. Another frequent example is the size information for C buffers: these are typically presented as arrays in
the Java API, where the length information is a built-in language construct.

<P>Note that <b>unsigned integer types</b> are also usually converted to the signed Java primitive type
of the same bit-size: thus, an <tt>SaUint32T</tt> becomes (a signed) <tt>int</tt> in the Java API. Although this could
in theory cause interpretation problems if e.g. arithmetic or relational operations were used carelessly,
in practice most unsigned integer types of the C API are used for special purposes, so this is not a problem:
<UL>
<LI>IDs only need an equality check,
<LI>Flags are defined by their bit positions: therefore only bitwise operations are used for manipulating them.
<LI>For many values (e.g. size or offset defined as <tt>SaUint64T</tt> in the C API) we can safely assume that the
actual values assigned to them will always be within a range where both
signed and unsigned types are interpreted the same way.
</UL>
However, there are a few exceptions, e.g. the <tt>majorVersion</tt> and <tt>minorVersion</tt> fields of
<A HREF="org/saforum/ais/Version.html" title="class in org.saforum.ais"><CODE>Version</CODE></A> are expected to be used in comparison operations, therefore they 
are declared as <tt>short</tt> instead of <tt>byte</tt>, so that the whole 8-bit unsigned range is included in their 
type.

<P>There are several ways <b>strings</b> are represented in the C API (e.g null-terminated strings,
character arrays, <tt>SaNameT</tt>). All of these types are represented by the <tt>String</tt>
class in the Java API. It is the
responsibility of the Java API implementation to carry out any conversion, if necessary.
 
<P>There are <b>C <tt>struct</tt>s</b> that encapsulate a buffer pointer and its length: these
are represented as Java arrays. Otherwise, C <tt>struct</tt>s are defined in Java as
public classes with public fields. For the sake of simplicity and effectiveness,
no code is added to them, not even setters or getters. The reasons for this arguable decision are the following:
<UL>
<LI>These classes are used as data transfer objects, i.e. they are only meant to transmit data between
the client code and the platform.
<LI>The likeliness of changing the existing fields of these structures is marginal,
since they come from the AIS C API specification and changing them in newer AIS versions would break the
compatibility with older AIS versions.
<LI>One potential function of setters and getters would be to provide validity checks for the fields of these
objects. However, the same validity checks are done by the AIS are servers when the objects are
actually passed to them, therefore doing validity checks in the setters/getters would leave to
duplicated functionality.
to
</UL>

<p><b>C <tt>union</tt>s</b> are replaced by a hierarchy of classes, the root class representing the union as a type,
subclasses representing particular union components.

<P><b>C arrays</b> are defined as Java arrays.

<P><b>Function pointers</b> -- callbacks -- are defined as interfaces with a
single method defining the signature of the callback</li>


<h4><i><a name="Methods" id="methods">Methods, Parameters, Return Values, and Exceptions</a></i></h4>

<P>The functions of the C API are mapped to methods of the Java API. In most cases 
there is <B>one-to-one</B> correspondence in functionality between the C function and the Java method.
In such cases, as explained <a href="#NamingExample">above</a>, typically the naming has been simplified in the Java API in such a manner
that the equivalent C function name is obvious. Noteworthy exceptions to the naming of such Java methods
is the initialization and finalization of handles:
<UL>
<LI>In the C API library handle lifecycle is controlled by <tt>sa&lt;Area&gt;Initialize()</tt>
and <tt>sa&lt;Area&gt;Finalize()</tt> functions. Applying the default naming convention
would lead to a <tt>finalize()</tt> method: in order to avoid confusion with the well-known 
method with the same name inherited from Object, the 
method name <tt>finalizeHandle()</tt> has been selected instead. For consistency,
<tt>initializeHandle()</tt> is used as its pair.
<LI>For other handles, the pair of <tt>create&lt;Entity&gt;()</tt>/<tt>destroy()</tt> method
names is used for life cycle control.
</UL>

<P>There are cases where a single C API function is <B>refactored</B> to several Java methods with different parameter lists.
These C functions use certain parameters to govern what the function actually should do. These functions are
decomposed into several Java methods. Below you can find some examples:
<UL>
<LI>The <tt>saAmfComponentRegister()</tt> function is refactored into different methods 
(see <A HREF="org/saforum/ais/amf/ComponentRegistry.html" title="interface in org.saforum.ais.amf"><CODE>ComponentRegistry</CODE></A> interface) for registering different component
types. E.g. one of these registers "normal" SA-aware coponents, another one registers 
registers proxied components (by their proxy).
Similarly, there are separated unregister methods for different component types, replacing
<tt>saAmfComponentUnregister()</tt>.
<LI>The <tt>sa&lt;Area&gt;&lt;Object&gt;Track()</tt> function of the Track API
(see Chapter "AIS Programming Model and naming Conventions" of the AIS overview document)
has been refactored into five different Java methods 
(see e.g. <A HREF="org/saforum/ais/amf/ProtectionGroupManager.html" title="interface in org.saforum.ais.amf"><CODE>ProtectionGroupManager</CODE></A>), each requesting
tracked object information, but in different manners:
<UL>
<LI><tt>&lt;Object&gt;Notification[] get&lt;Object&gt;(...)</tt>: single synchronous request,
<LI><tt>void get&lt;Object&gt;Async(...)</tt>: single asynchronous request,
<LI><tt>&lt;Object&gt;Notification[] get&lt;Object&gt;ThenStart&lt;Object&gt;Tracking(...)</tt>: single synchronous request + continuous tracking 
<LI><tt>void get&lt;Object&gt;AsyncThenStart&lt;Object&gt;Tracking(...)</tt>: single asynchronous request + continuous tracking 
<LI><tt>void start&lt;Object&gt;Tracking(...)</tt>: continuous tracking
</UL>
</UL>

The documentation of the Java methods contains a reference to the equivalent C functions, including information
on the specific parameter values that belong to a "refactored" Java method. 

<p>In Java, memory is never freed explicitly. Instead, the garbage collector reclaims
unused memory. Therefore, C API functions freeing up memory (typically named as 
<tt>sa&lt;Area&gt;&lt;SomeEntity&gt;Free()</tt> do not have
their counterparts in Java.

<p>In the C API, a "handle" is often passed to a function. In Java, this is
not the case. The "handle" is the object on which the method is invoked.
Within the method, <tt>this</tt> can be used to explicitly refer to this
implicit parameter.</p>

<p>
The C AIS API follows a typical C <B>error handling</b> convention:
the return value of each API functions invoked by the AIS Component is an integer value
(enum type <tt>SaAisErrorT</tt>) representing the error status of the executed function.
<tt>SA_AIS_OK</tt> represents a successful execution,
whereas <tt>SA_AIS_ERR_&lt;SOME_ERROR&gt;</tt> values represent possible errors. 

<p>Errors are handled using exceptions in Java, therefore the Java AIS API declares
appropriate exceptions for the possible AIS errors.
For each <tt>SA_AIS_ERR_&lt;SOME_ERROR&gt;</tt> value there is an <tt>Ais&lt;SomeError&gt;Exception</tt>
class declared in the <A HREF="org/saforum/ais/package-summary.html"><CODE>org.saforum.ais</CODE></A> package.
So, Java AIS API methods throw one of these exceptions instead of returning an error value.
(If no exception is thrown, the method executed successfully
i.e. this is the equivalent behaviour with the C function returning <tt>SA_AIS_OK</tt>).
There is a superclass <A HREF="org/saforum/ais/AisException.html" title="class in org.saforum.ais"><CODE>AisException</CODE></A> for all the exception classes:
it is never thrown by the API but can be used by the applications for error handling, 
especially if the error handling code is generic and applies to all possible exceptions thrown by the API method.
(However, note that many argue that catching individual exceptions is the best ? and preferred -
programming style in Java...) The <A HREF="org/saforum/ais/AisException.html" title="class in org.saforum.ais"><CODE>AisException</CODE></A> is a checked exception (i.e. <tt>Exception</tt> subclass),
which means that the clients of AIS API methods are forced to handle the <tt>Ais&lt;SomeError&gt;Exception</tt>s
either by catching the exceptions or by explicitly declaring them in the enclosing methods.
As usual in Java, extra status information is embedded in an exception when it is thrown:
e.g. a stack trace, a possible nested exception, a message string. </p>

<P>There is an enumerated type <A HREF="org/saforum/ais/AisStatus.html" title="enum in org.saforum.ais"><CODE>AisStatus</CODE></A> that corresponds to the C
<tt>SaAisErrorT</tt> values (including <tt>SA_AIS_OK</tt>).
It is used to indicate the status of operations executed asynchronously, i.e.
the status of an operation other than the one initiated by the actual method call. Some examples are as follows:
<UL>
<LI>The <tt>response()</tt> method of <A HREF="org/saforum/ais/amf/AmfHandle.html" title="interface in org.saforum.ais.amf"><CODE>AmfHandle</CODE></A> uses <A HREF="org/saforum/ais/AisStatus.html" title="enum in org.saforum.ais"><CODE>AisStatus</CODE></A>
to indicate the result of a formerly invoked AMF callback.
<LI>Callbacks used as a response to asynchronous API calls also use 
<A HREF="org/saforum/ais/AisStatus.html" title="enum in org.saforum.ais"><CODE>AisStatus</CODE></A> to indicate the status of the asynchronous 
call (see e.g. <A HREF="org/saforum/ais/amf/TrackProtectionGroupCallback.html" title="interface in org.saforum.ais.amf"><CODE>TrackProtectionGroupCallback</CODE></A>)

</UL>

<p>Often in the C API, the parameters being passed must be accompanied by
<B>descriptive data</B>. For example, often a pointer to an array is passed along
with a second parameter giving the number of (valid) elements. In the Java
API, this is not done. Instead, Java's type checking/safety and ability to
interrogate objects is used. For example, to get the number of elements in an
array, the "<tt>.length</tt>" attribute is used, etc.</p>


<p>The replacement of handles with object references, the use of exceptions
instead of a status return, and the elimination of descriptive parameters
means that the Java methods have far fewer parameters (approximately one
half, on average) compared to the C functions. So the signatures are quite
different. Also, the elimination of the status return frees up this usage for
other return values. Hence, there are very few "out" parameters in the Java
API.</p>

<h4><i><a name="Generic" id="Generic">Generic Types</a></i></h4>

<p>Java generic types are used to create a uniform factory framework. The C API
"factories" (i.e. the <tt>sa&lt;Area&gt;Initialize()</tt> functions) provide the same
initialization scheme, but still have to be declared separately in the C API for each service because
of the differences in the formal parameter list. By using a generic interface,
the Java API can capture the uniformity of library handle initialization in a more elegant way.
Thus, the Java API declares a generic <tt>initializeHandle()</tt> method (see <A HREF="org/saforum/ais/Factory.html" title="interface in org.saforum.ais"><CODE>Factory</CODE></A>).
There are two actual differences between the 
initializers for the different services: the set of callbacks supported by the 
service and the actual library handle implementation returned by the factory.
Hence, in the interface you will find two type variables: 
S" for Service (i.e. the library handle) and "C" for Callbacks.</p>


<hr>

<h2><a name="Copyrights"></a>OWNERSHIP OF SPECIFICATION AND COPYRIGHTS.
</h2>
Copyright 2008 by the Service Availability Forum. All rights reserved.
<p>
Permission to use, copy, and distribute this mapping specification for any
purpose without fee is hereby granted, provided that this entire notice
is included in all copies. No permission is granted for, and users are
prohibited from, modifying or making derivative works of the mapping
specification.
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
SAIM-AIS-R2-JD-A.01.01</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Created by Service Availability Forum, 2008
</BODY>
</HTML>
